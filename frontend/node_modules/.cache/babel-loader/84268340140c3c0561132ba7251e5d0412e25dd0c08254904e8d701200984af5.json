{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-explicit-any */\nconst BASE_URL = '/api';\n\n// a promise resolved after a given delay\nfunction wait(delay) {\n  return new Promise(resolve => {\n    setTimeout(resolve, delay);\n  });\n}\n\n// To have autocompletion and avoid mistypes\n\nfunction request(url, method = 'GET', data = null // we can send any data to the server\n) {\n  const options = {\n    method\n  };\n  if (data) {\n    // We add body and Content-Type only for the requests with data\n    options.body = JSON.stringify(data);\n    options.headers = {\n      'Content-Type': 'application/json; charset=UTF-8'\n    };\n  }\n\n  // for a demo purpose we emulate a delay to see if Loaders work\n  return wait(300).then(() => fetch(BASE_URL + url, options)).then(response => response.json());\n}\nexport const client = {\n  get: url => request(url),\n  post: (url, data) => request(url, 'POST', data),\n  patch: (url, data) => request(url, 'PATCH', data),\n  delete: url => request(url, 'DELETE')\n};\n\n// const BASE_URL = '/api';\n\n// // a promise resolved after a given delay\n// function wait(delay: number) {\n//   return new Promise(resolve => {\n//     setTimeout(resolve, delay);\n//   });\n// }\n\n// type RequestMethod = 'GET' | 'POST' | 'PATCH' | 'DELETE';\n\n// function request<T>(\n//   url: string,\n//   method: RequestMethod = 'GET',\n//   data: any = null,\n// ): Promise<T> {\n//   const options: RequestInit = { method };\n\n//   if (data) {\n//     options.body = JSON.stringify(data);\n//     options.headers = {\n//       'Content-Type': 'application/json; charset=UTF-8',\n//     };\n//   }\n\n//   return wait(300)\n//     .then(() => fetch(BASE_URL + url, options))\n//     .then(response => response.json());\n// }\n\n// export const client = {\n//   get: <T>(url: string) => request<T>(url),\n//   post: <T>(url: string, data: any) => request<T>(url, 'POST', data),\n//   patch: <T>(url: string, data: any) => request<T>(url, 'PATCH', data),\n//   delete: (url: string) => request(url, 'DELETE'),\n// };","map":{"version":3,"names":["BASE_URL","wait","delay","Promise","resolve","setTimeout","request","url","method","data","options","body","JSON","stringify","headers","then","fetch","response","json","client","get","post","patch","delete"],"sources":["C:/Users/rusip/wander-wave-project/frontend/src/helpers/fetchClient.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\r\nconst BASE_URL = '/api';\r\n\r\n// a promise resolved after a given delay\r\nfunction wait(delay: number) {\r\n  return new Promise(resolve => {\r\n    setTimeout(resolve, delay);\r\n  });\r\n}\r\n\r\n// To have autocompletion and avoid mistypes\r\ntype RequestMethod = 'GET' | 'POST' | 'PATCH' | 'DELETE';\r\n\r\nfunction request<T>(\r\n  url: string,\r\n  method: RequestMethod = 'GET',\r\n  data: any = null, // we can send any data to the server\r\n): Promise<T> {\r\n  const options: RequestInit = { method };\r\n\r\n  if (data) {\r\n    // We add body and Content-Type only for the requests with data\r\n    options.body = JSON.stringify(data);\r\n    options.headers = {\r\n      'Content-Type': 'application/json; charset=UTF-8',\r\n    };\r\n  }\r\n\r\n  // for a demo purpose we emulate a delay to see if Loaders work\r\n  return wait(300)\r\n    .then(() => fetch(BASE_URL + url, options))\r\n    .then(response => response.json());\r\n}\r\n\r\nexport const client = {\r\n  get: <T>(url: string) => request<T>(url),\r\n  post: <T>(url: string, data: any) => request<T>(url, 'POST', data),\r\n  patch: <T>(url: string, data: any) => request<T>(url, 'PATCH', data),\r\n  delete: (url: string) => request(url, 'DELETE'),\r\n};\r\n\r\n// const BASE_URL = '/api';\r\n\r\n// // a promise resolved after a given delay\r\n// function wait(delay: number) {\r\n//   return new Promise(resolve => {\r\n//     setTimeout(resolve, delay);\r\n//   });\r\n// }\r\n\r\n// type RequestMethod = 'GET' | 'POST' | 'PATCH' | 'DELETE';\r\n\r\n// function request<T>(\r\n//   url: string,\r\n//   method: RequestMethod = 'GET',\r\n//   data: any = null,\r\n// ): Promise<T> {\r\n//   const options: RequestInit = { method };\r\n\r\n//   if (data) {\r\n//     options.body = JSON.stringify(data);\r\n//     options.headers = {\r\n//       'Content-Type': 'application/json; charset=UTF-8',\r\n//     };\r\n//   }\r\n\r\n//   return wait(300)\r\n//     .then(() => fetch(BASE_URL + url, options))\r\n//     .then(response => response.json());\r\n// }\r\n\r\n// export const client = {\r\n//   get: <T>(url: string) => request<T>(url),\r\n//   post: <T>(url: string, data: any) => request<T>(url, 'POST', data),\r\n//   patch: <T>(url: string, data: any) => request<T>(url, 'PATCH', data),\r\n//   delete: (url: string) => request(url, 'DELETE'),\r\n// };\r\n"],"mappings":"AAAA;AACA,MAAMA,QAAQ,GAAG,MAAM;;AAEvB;AACA,SAASC,IAAIA,CAACC,KAAa,EAAE;EAC3B,OAAO,IAAIC,OAAO,CAACC,OAAO,IAAI;IAC5BC,UAAU,CAACD,OAAO,EAAEF,KAAK,CAAC;EAC5B,CAAC,CAAC;AACJ;;AAEA;;AAGA,SAASI,OAAOA,CACdC,GAAW,EACXC,MAAqB,GAAG,KAAK,EAC7BC,IAAS,GAAG,IAAI,CAAE;AAAA,EACN;EACZ,MAAMC,OAAoB,GAAG;IAAEF;EAAO,CAAC;EAEvC,IAAIC,IAAI,EAAE;IACR;IACAC,OAAO,CAACC,IAAI,GAAGC,IAAI,CAACC,SAAS,CAACJ,IAAI,CAAC;IACnCC,OAAO,CAACI,OAAO,GAAG;MAChB,cAAc,EAAE;IAClB,CAAC;EACH;;EAEA;EACA,OAAOb,IAAI,CAAC,GAAG,CAAC,CACbc,IAAI,CAAC,MAAMC,KAAK,CAAChB,QAAQ,GAAGO,GAAG,EAAEG,OAAO,CAAC,CAAC,CAC1CK,IAAI,CAACE,QAAQ,IAAIA,QAAQ,CAACC,IAAI,CAAC,CAAC,CAAC;AACtC;AAEA,OAAO,MAAMC,MAAM,GAAG;EACpBC,GAAG,EAAMb,GAAW,IAAKD,OAAO,CAAIC,GAAG,CAAC;EACxCc,IAAI,EAAEA,CAAId,GAAW,EAAEE,IAAS,KAAKH,OAAO,CAAIC,GAAG,EAAE,MAAM,EAAEE,IAAI,CAAC;EAClEa,KAAK,EAAEA,CAAIf,GAAW,EAAEE,IAAS,KAAKH,OAAO,CAAIC,GAAG,EAAE,OAAO,EAAEE,IAAI,CAAC;EACpEc,MAAM,EAAGhB,GAAW,IAAKD,OAAO,CAACC,GAAG,EAAE,QAAQ;AAChD,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}